package com.example.demo;

import java.util.ArrayList;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;


@SpringBootApplication
public class TestApplication {

	public static void main(String[] args) {
		SpringApplication.run(TestApplication.class, args);
	

	// 캐릭터들이 살만한 꽃동네를 생성(스프링 빌리지)
	//  -> 주민 한명 입주(급하냥)
	// 급하냥의 역할 : 마을의 입구에서 방문객들의 요청을 가장먼저 받아 처리하는 역할
	//   -> 컨트롤러를 좀 돌려얘기해봄
	
	// 시나리오
	// 방문객이 옴.(http://localhost:8080/test1)
	// 마을 입구에서 이것을 확인한 급하냥은 즉시 요청을 접수.
	// 성격이 급한 급하냥은 신속하게 처리하기 위해 미리 준비해둔 test.html을
	// 방문객에게 보여줌(view단 호출)
	// 방문객은 응답으로 test.html파일을 볼수 있음
	
	// 시나리오2
	// 생각보다 스프링빌리지에 방문객이 많아졌음
	// 방문객들이 많아지다 보니 서로 소식을 전할 주민 게시판 요청이 들어옴.
	// 급하냥(컨트롤러)의 업무부담 증가.
	//  -> 급하냥 혼자서 게시판을 만들고 관리하려니까 너무 힘듬.
	//  -> 환영인사에만 집중하고 글을 받아서 내용을 분석하고 창고에 안전하게
	//      보관하는 일까지 하기위한 전문가를 초빙.
	
	// 급하냥은 자신의 일을 도와줄 두명의 전문가 친구를 초빙.
	// 와플곰 : 요청의 핵심을 파악하고 실질적인 업무를 처리하는 서비스 전문가(@Service)
	// 카피바라 : 데이터를 창고에 안전하게 보관하고 꺼내오는 담당자
	//   -> DB에 안전하게 보관하고 꺼내오는 데이터 전문가.
	
	// 사실 이 모든일들은 급하냥(컨트롤러)이 혼자 처리하는거 가능.
	//  -> 하지만 급하냥, 와플곰, 카피바라가 각자 영역들을 문제없이 처리해 준다면
	//     더 효율적인 업무처리가 가능.
	
	//  -> 어디든 운영을 할때 덩치(체급)이 커지면 관리자, 실무자 등등 구분하는것처럼
	//     스프링에서도 컨트롤러 서비스 db 등을 각자 분할하여 처리.
	
	// 시나리오 3
	// 페이지 상세보기, 게시글 수정, 삭제.
	
	// 급하냥(컨트롤러)이 여태껏 보여줬던건 게시글 전체 내용일뿐
	//  -> 정해진 주소로 오는 요청만 처리.
	// 상세 보기가 필요해진 지금 주소 자체에 정보가 담겨오는 요청도 처리할필요가 있음.
	//  -> URL에 포함된 숫자를 정확히 파악하여 서비스단(와플곰)에 요청을 넘겨줄거임
	//     (와플곰아 1번 게시글 가져와줘), 2,3번도 유동적으로 사용자에 요청에따라 
	//      처리할수 있음.
	
	// 시나리오 4
	// 회원가입, 로그인, 로그아웃 구현하기.
	// 여기저기 몰려와서 방명록 남기고 그러다보니 조금더 체계적인 관리를 진행할필요가 생김
	// 정식으로 등록된 주민(사용자), 방문객을 구분할 예정
	// 주민들에게만 특정한 권한을 부여할 예정. -> 이런것들을 처리하기위해 스프링 시큐리티 도입.
	
	// 시큐리티 시스템은 두가지의 핵심적인 일을 진행함.
	//  -> 시큐리티는 경비견 누렁이가 담당할거임.
	
	// 1. 인증(Authentication) : 멍멍 신분증 보여주개!
	//  - 마을(스프링 시스템)에 들어오려는 사람이 누구인지 확인하는 과정.
	//  - 사용자가 아이디와 비밀번호를 제출(로그인)하면 누렁이가 
	//     db에 등록된 정보와 일치하는지 확인.
	
	// 2. 인가(Authorization) : 마을사람이지만 여기는 출입 통제 구역이개.
	//  						여기는 프라이빗 룸이개.
	//  - 신원이 확인된 사람이라 해도 모든것을 할수 있는게 아니다 라는 얘기.
	//  - 해당 행동에 대한 권한이 있는지를 확인하는 과정.
	//  - 예를들어 게시글 작성은 주민등급만 가능하고 마을 관리는 마을 이장 등급만 가능하도록 설정.
	
	// 과거에는 이런것들을 코딩하려면 개발자가 직접 체계를 잡아 쿠키와 세션관리를
	// 일일히 해줘야 했기때문에 개복잡.
	
	// -> 최근에는 스프링 시큐리티를 활용하여 쿠키 세션관리 및 회원 가입등을 쉽게
	//    처리할수 있도록 시큐리티의 도움을 받는 추세.
	
	// 당장 시큐리티로 뭐할거임?
	// 회원가입, 로그인, 로그아웃 기능 처리.
	
	// 에러가 났을때는 어떻게 대처해야하는가?
	// 1. 에러 메세지부터 찾아야함.
	// 2. 에러 메세지를 기반으로 아는거면 해결
	//     -> 모르는거먼 서칭해야함.
	// 3. 원인 찾았으면 테스트.
	
	// Bean 객체
	//  -> 개발자가 직접 정의한 메서드들을 스프링이 시작될때 자동으로 올리도록 유도하는 객체.
	//      ( 스프링 컨테이너에 빈으로 등록하도록 지정하는 역할)
	//  -> Bean 객체는 스프링(컨테이너)에 의해 생성되고 관리된다.
	//  -> Bean 객체의 경우는 사용자의 url 요청시 불러질수도 있지만.
	//     정확히는 특정한 상황에서 요청이 없더라도 불러지는 메서드 혹은 객체라 할수있음.
	//  쉽게 얘기하자면 spring의 static
	
	// 시나리오 5
	// 댓글달기.
	// 공지용이 아니라 활발한 커뮤니티성 페이지로 진화.
	// 관계설정
	// 댓글기능을 추가.
	// 게시글과 댓글의 관계를 어떻게 설정하느냐
	// 하나의 게시글은 여러개의 댓글을 가질수 있음.
	// 하나의 댓글이 여러개의 게시글을 가질수 있나요?(x)
	//  -> 즉 게시글과 댓글은 순서대로 표기하자면 1:N 이라는 관계설정이 필요.
	
	// 시나리오 6.
	// 댓글 수정, 삭제하기
	//  -> 댓글은 인증된 사용자들만 댓글을 쓸 수 있도록 처리
	//  -> 인가는? (로그인한 사용자들만 댓글을 쓰는 것 자체가 인가처리도 완료)
	//  -> 댓글을 쓰는 것은 인증된 사용자들만 댓글을 쓰는게 맞음
	//     하지만 댓글의 수정은? -> 당연히 쓴사람만 가능해야하지 않을까?
	//  -> 댓글 삭제 -> 마찬가지 아닌가?
	//  로그인한 사용자가 이 댓글을 직접 쓴 사람이 맞는지를 확인하는 작업이
	//  앞으로는 필요할 것이다. (권한확인)
	
	// 시나리오 7
	// 공손한 따봉(추천)
	// 사용자, 게시글
	//  -> 한명의 사용자가 여러개의 게시글을 작성할 수 있음
	// 예시상황
	//  -> 사용자1이 게시글을 보고 추천버튼을 클릭
	//  -> 컨트롤러(급하냥)가 이것을 보고 게시글에 대한 추천 요청이 도착했고
	//     요청자는 유저1이야 라고 와플곰에게 전달
	//  -> 서비스(와플곰)은 추천 명단을 확인 후 없다면 추천처리 완료 메세지를 전달
	//     repo로 넘겨야함
	 
	// 시나리오 8
	// 파일 업로드
	// 사용자들에게 자기 자신을 표현할 수 있는 방안을 확장하거나
	// 혹은 적절한 이미지를 업로드함으로써 시스템(서비스)를 더 효율적이고
	// 혹은 상품 판매에 유리함을 가져가도록 설계할 수 있음
	// 왠만한 웹 서비스에서는 파일 업로드 기능은 필수
	//  -> stream, 폼에 대해서도 변경이 필요
	// 특히 파일 업로드 다운로드 기능 구현에는 경로 설정과 저장공간에 대한 이해도가 필수
	
	// 1. 템플릿 - 폼에 MultipartFile이라는 객체에 담아서 전송(컨트롤러/급하냥)
	//  - 이 객체 안에는 파일의 원본 이름, 크기, 내용물등의 정보를 흔히 담음
	
	// 2. 컨트롤러에서는 이 내용을 서비스로 잘만 던져주면됨.
	//  - 첨부 파일의 처리는 흔히 서비스단에서 하거나 혹은 파일 관련 메서드를 따로 만들어 처리
	//  - 파일을 외부에서 받아올 때는 바이트 코드 타입으로 가져옴 -> (물리적파일)원본 파일로 변경
	//  - 파일을 저장할 때는 다른 사용자와 같은 이름의 파일일수 있기 때문에
	//    원본의 이름을 따로 저장한 후 고유한 이름을 새로 만들어 저장하는 것이 안전
	//  - 저장을 하려면 서버의 특정 폴더로 이동
	//    (엔티티는 아무것도 안해도됨?)
	//  - 브라우저(크롬)가 저장된 이미지를 화면에 보여주려면 서버는 특정한 URL로
	//    요청이 왔을때 실제 파일 저장 폴더에서 해당 파일을 찾아 보내주는 역할을 해야함
	//    -> 기준은 서버에 저장되어있는 파일의 위치(정적 리소스 매핑)
	
	// 시나리오 9
	// 정규표현식(Regular Expression)과 유효성 검사(Validation Check)
	
	// 유효성 검사 : 사용자 혹은 받아온 데이터가 적합한지 검증하는 검사 방식
	//  -> 사용자가 내용을 입력했는데 이게 우리 서비스 기준에 맞게 제대로 입력했는지 확인
	
	// 여태 이런거 없이 잘했는데?
	//  -> 지금가지는 사실 쓰는 사람이 우리들 밖에 없었음. 
	//     근데 만약 이 서비스가 외부에 호스팅되는 상황이었다면?
	//  -> 무의미한 데이터들로 우리의 데이터베이스가 가득차버릴수 있음
	//     혹은 이런 상황 때문에 무의미한 시스템 에러가 발생할수도 있음
	
	// 의존성 추가로 다음의 라이브러리가 필요
	// 
	// BindingResult와 principal을 잘 이용하면 간단하게 강력한 유효성 검사를 만들 수 있음
	
	// 유효성 검사를 통해 우리 시스템에 맞는 올바른 데이터들만 다루도록 진행
	
	// 정규 표현식 : 유효성 검사로 처리하기 어려운 양식들을 처리해 수 있는 일종으 ㅣ탐지기
	//  -> 특정한 규칙을 가진 문자열을 찾아내거나 바꾸거나 분리하기 위해 사용하는
	//     문자열 형식의 공식
	
	// 전화번호를 예를들면 '-'을 쓰는 사람이 있고 안쓰는 사람이 있음
	//  -> 하지만 전원 전화번호를 입력한건 맞지만 컴퓨터의 입장은?
	
	// 정규표현식으로 할 수 있는 것들
	// 전화번호 검증, 이메일 검증, 주민번호 검증
	//  -> 일정한 형식을 가진 모든 텍스트를 검증할 수 있음
	
	// 정규표현식의 기본 문법
	// . : 아무 문자 하나와 일치
	// * : 앞의 문자가 0번 이상 반복
	// + : 앞의 문자가 1번 이상 반복
	// ? : 앞의 문자가 0번 혹은 1번 나타남
	// [] : 괄호 안의 문자 중 하나와 일치
	// ^ : 문자열의 시작과 일치
	//     ^안녕 : 안녕 이라는 단어로 시작하는 문자열을 찾아주세요.
	//     안녕하세요 : 통과, 하이 안녕하세요 : X
	// $ : 문자열의 끝과 일치
	//     안녕$ : 안녕이라는 단어로 끝나는가?
	// \d : 숫자 하나와 일치 [0-9]
	//      영문자는 [a-z], [A-Z]
	// 		한글 [가-힣]
	// \w : 문자 하나와 일치(숫자, 알파벳, _)
	// \s : 공백 하나와 일치(스페이스, 탭, 줄바꿈)
	// {n} : 앞의 문자가 정확히 3번 반복
	//       \d{3} : 숫자 3개
	// {n, m} : 앞의 문자가 n번 이상 m번 이하 반복
	//          \w{2, 5} : 문자 2~5개
	
	// 정규 표현식 활용 패턴
	// 이메일 정규 표현식 리턴
	// ^ : 문자열 뒤의 대괄호 패턴으로 시작해야함을 의미
	// [a-zA-Z0-9] : 영문 대소문자 + 숫자 허용
	// ._%+- : 대괄호 내부에 있으면 이런 특수 문자 사용을 허용하겠다는 의미
	// + : 이 패턴이 한번 이상 반복될 수 있음을 의미
	// @ : 이메일이니까 이메일을 구분하는 로컬 / 도메일 파트
	// \\ : 도메인 명과 최상위 도메인을 구분하는 . 자체를 표현
	//      gmail.com
	// {2,6} : 최소 2글자에서 최대 6글자까지의 길이를 허용
	// $ : 표현식 끝
	// 아래의 패턴이 깰라면 충분히 깰수는 있음
	// test@test
	// 
//	String regExp = "^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,6}$";
//	// 자바 기준으로 정규표현식을 활용하기 위해서는
//	// Pattern, Matcher라는 클래스를 활용해서 처리할 필요가 있음
//	Pattern p1 = Pattern.compile(regExp);
//	
//	String test1 = "nureong@gmail.com";
//	String test2 = "wafflegom@";
//	
//	// 입력받은 이메일에 대해 Matcher 클래스를 통해 검사
//	Matcher m1 = p1.matcher(test1);
//
//	// 정규 표현식을 기반으로 검사하는 메서드
//	if (m1.matches()) {
//	    System.out.println("합격이예용");
//	
//	}

//		String recipe = "비밀 반죽: [밀가루] 500g과 [계란] 3개, 그리고 약간의 [사랑]을 넣고 섞어주세요.";
//				
//		// [가-힣] : 한글들만 뽑아 내겠다.
//		// 
//		// 그래서 이스케이프 코드를 통해 말드대로 문자 [의 시작을 찾겠다는 의미
//		// 결론: 대괄호 안에 있는 한글들을 추출해주세요!
//		Pattern pattern = Pattern.compile("\\[([가-힣]+)\\]");
//		Matcher matcher = pattern.matcher(recipe);
//		
//        List<String> ingredients = new ArrayList<>();
//        // find(): 패턴과 일치하는 다음 부분을 찾으면 true 반환
//        while (matcher.find()) {
//            // group(1): 첫 번째 괄호 그룹에 해당하는 내용("밀가루", "계란", "사랑")을 가져옴
//            ingredients.add(matcher.group(1));
//        }
//        
////        급하냥의 임무: "고객 후기 게시판에 전화번호(010-1234-5678)나 이메일(loopy@village.com) 
////        같은 개인정보가 그대로 노출되면 큰일 나! 전화번호는 가운데 4자리를 '***'로,
////        이메일은 아이디 앞 3글자 빼고 전부 ''로 바꿔주는 자동 마스킹 시스템을 만들어줘! 빨리!"
//        
//        String review = "배송 최고예요! 제 번호는 010-1234-5678 이고, 이메일은 loopy@village.com 입니다. 연락주세요!";
//        
//        String phoneReg = "(\\d{3})-(\\d{4})-(\\d{4})";
//        // replaceAll : 정규 표현식을 사용하여 텍스트 내의 특정 패턴을 찾아 변경
//        // $1 : phoneReg의 변수에서 첫번째 그룹인 d{3}에 해당하는 부분을 가져옴
//        String maskedReview = review.replaceAll(phoneReg, "$1-****-$3");
//        String emailRegex = "([a-zA-Z0-9]{3})([a-zA-Z0-9]+)(@[a-zA-Z0-9.-]+\\.[a-zA-Z]+)";
//        maskedReview = maskedReview.replaceAll(emailRegex, "$1****$3");
//        
		
		// 정규표현식 결론 
		//  -> 몰라도 코딩하는데 조금 불편할 순 있지만 지장은 없음
		//  -> 근데 익숙해지면 텍스트 작업은 겁나 빠르게 처리할 수 있음
		
		// 시나리오 10 
		// 페이징처리(기존 시나리오 페이징 처리는 폐쇄)
		// 페이지 : 가상의 메모리를 동일한 크기의 블록으로 나눈 단위
		// 페이징 : CS에서 사용하는 메모리 관리 기법
		//  -> OS가 프로세스에서 사용하느 메모리를 효율적으로 관리하기 위해 사용하는 방법
		
		// 페이징 처리 : UI에 표현되는 대량의 데이터를 차근차근 나누어 처리하기 위해 사용하는 기법
		//  -> 단순하게 화면에 적절히 표현한다의 문제를 넘어서 서버의 부하나 사용자가 활요할 장치의 부담도 줄일 수 있다
		
		
		// 페이징은 도서관과 비교해보면 이해가 쉬워짐
		// 도서관 전체 : 데이터 베이스에 저장된  데이터
		// 한 책장(서가) : 한 페이지에 보여줄 데이터
		// 도서관 안내원 : Pageable 객체
		// 책장 목록표 : Page 객체
		
		
		// 시나리오 11
		// REST API(RESTful을 추구해야하는게 맞긴한데...)
		// API의 내부 구조
		// 클라이언트가 우리 API 주소(URL)를 찾아온 상황
		//  -> 그렇다면 해당 주소를 가진 메서드(API)는 뭘 줘야하지?
		//  -> 기본적으로 어떠한 데이터를 돌려줄지를 고민해봐야한다
		//  -> 프로토콜상 요청과 응답으로 넘기고 받아오는 레시피가 있음
		//     (JSON, YAML)
		
		// JSON(JavaScript Object Notation)
		//  - 데이터를 저장하고 교환하기위한 텍스트 기반의 경량 데이터 교환 형식
		//  - 사람이 읽을 수 있고 시스템에서 구문을 분석할 수 있는 방식으로 설계
		
		//  - 다양한 프로그래밍 언어에서 활용 가능
		//  - 가벼움(과거에는 XML을 이용 -> 하지만 JSON은 XML 보다 간결하고 가볍다)
		//  - XML은 읽는게 개빡쳤음
		//  - XML에 비하면 JSON은 k-v 형태로 구성되어 있어서 인간 친화적
		//  - 텍스트 기반의 전송
		//    (모든 데이터가 텍스트 형식으로 저장되어있기 때문에 네트워크 전송에 적합)
		
		
		
		
		
		
		
	}
}


